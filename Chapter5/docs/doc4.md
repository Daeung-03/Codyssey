# Document for Problem4 by Daeung
---

## Flask vs Gunicorn: 배포 시 Gunicorn 사용 이유

### Flask
- **정의**: Python으로 작성된 경량 웹 프레임워크
- **역할**: 웹 애플리케이션 개발을 위한 도구
- **특징**: 
  - 마이크로 프레임워크
  - 간단하고 유연한 구조
  - 개발 서버 내장

### Gunicorn (Green Unicorn)
- **정의**: Python WSGI HTTP Server
- **역할**: 웹 서버와 Python 웹 애플리케이션 간의 인터페이스 역할
- **특징**:
  - 멀티 워커 프로세스 지원
  - 높은 성능과 안정성
  - 프로덕션 환경에 최적화

## 2. 주요 차이점

| 구분 | Flask | Gunicorn |
|------|-------|----------|
| **유형** | 웹 프레임워크 | WSGI HTTP 서버 |
| **용도** | 애플리케이션 개발 | 애플리케이션 서빙 |
| **환경** | 개발 환경 | 프로덕션 환경 |
| **성능** | 단일 쓰레드, 낮은 성능 | 멀티 프로세스, 높은 성능 |
| **동시성** | 제한적 | 다중 요청 동시 처리 |
| **안정성** | 개발용, 제한적 | 프로덕션 레벨 안정성 |

## 3. Flask 내장 서버의 한계

Flask 기본 실행 방식
if name == 'main':
app.run(debug=True, host='0.0.0.0', port=5000)

### 문제점
- **단일 쓰레드**: 한 번에 하나의 요청만 처리 가능
- **낮은 성능**: 많은 동시 접속자 처리 불가
- **보안 취약**: 프로덕션 환경에 적합하지 않음
- **디버그 모드**: 개발용으로만 설계됨

## 4. 배포 시 Gunicorn 사용 이유

### 4.1 성능 향상
Gunicorn 멀티 워커 실행
gunicorn main:app --workers 4 --bind 0.0.0.0:80

- **멀티 프로세스**: CPU 코어 수만큼 워커 프로세스 생성
- **병렬 처리**: 동시에 여러 요청 처리 가능
- **처리량 증가**: Flask 내장 서버 대비 10배 이상 성능 향상

### 4.2 안정성 보장
- **프로세스 관리**: 워커 프로세스가 죽으면 자동으로 재시작
- **메모리 관리**: 메모리 누수 방지를 위한 워커 재시작 기능
- **graceful shutdown**: 안전한 서버 종료 처리

### 4.3 확장성
- **워커 수 조절**: 트래픽에 따라 워커 프로세스 수 조정 가능
- **로드 밸런싱**: 내부적으로 요청 분산 처리
- **리소스 최적화**: CPU와 메모리 사용량 최적화

### 4.4 프로덕션 환경 최적화
프로덕션 환경 Gunicorn 설정

## 5. 관계 정리

[클라이언트] → [Gunicorn] → [Flask App]

- **Flask**: 비즈니스 로직과 웹 애플리케이션 구현
- **Gunicorn**: Flask 애플리케이션을 안정적으로 서빙

## 결론

배포 환경에서 Gunicorn을 사용하는 이유는 Flask 내장 서버의 성능과 안정성 한계를 극복하고, 프로덕션 환경에서 요구되는 높은 처리량과 안정성을 제공하기 위함입니다.

## .dockerignore 파일: 역할과 항목별 설명

### 정의
- Docker 이미지 빌드 시 특정 파일이나 디렉토리를 제외하기 위한 설정 파일
- `.gitignore`와 유사한 역할을 하는 Docker 전용 파일

### 위치
- **Dockerfile과 같은 디렉토리**에 위치
- 파일명: `.dockerignore` (확장자 없음)

## 2. .dockerignore의 주요 역할

### 2.1 빌드 성능 향상
- 불필요한 파일 복사 방지로 **빌드 시간 단축**
- Docker context 크기 감소로 **네트워크 전송 시간 절약**

### 2.2 보안 강화
- 민감한 정보가 포함된 파일의 **이미지 포함 방지**
- 환경 설정 파일, 비밀키 등의 **보안 정보 보호**

### 2.3 이미지 크기 최적화
- 불필요한 파일 제외로 **Docker 이미지 용량 감소**
- 효율적인 **컨테이너 배포 및 저장소 관리**

## 2. 각 항목별 상세 설명

### 2.1 .git

.git

**제외 이유:**
- Git 저장소의 메타데이터와 버전 관리 정보가 담긴 디렉토리
- 컨테이너 실행 시 Git 히스토리나 브랜치 정보는 불필요함
- 수십 MB에서 수백 MB의 용량을 차지할 수 있어 이미지 크기 증가 원인
- 보안상 Git 커밋 히스토리나 개발 과정이 프로덕션 이미지에 노출되는 것을 방지

### 2.2 .gitignore

.gitignore

**제외 이유:**
- Git에서 추적하지 않을 파일들을 명시하는 설정 파일
- 컨테이너 런타임에서는 Git 관련 설정이 전혀 필요 없음
- 개발 환경에서만 사용되는 메타데이터 파일
- 이미지 크기 최적화를 위한 불필요한 설정 파일 제거

### 2.3 .dockerignore

.dockerignore


**제외 이유:**
- Docker 빌드 시 제외할 파일들을 명시하는 설정 파일
- 이미지가 빌드된 후에는 더 이상 필요하지 않은 메타데이터
- 컨테이너 내부에서 `.dockerignore` 파일 자체는 사용되지 않음
- 빌드 관련 설정 정보가 프로덕션 환경에 노출되는 것을 방지


### 2.4 Dockerfile

Dockerfile

**제외 이유:**
- Docker 이미지를 생성하기 위한 빌드 설정 파일
- 이미지가 완성된 후에는 빌드 명령어들이 더 이상 필요하지 않음
- 보안상 Docker 이미지의 빌드 과정이나 구조가 외부에 노출되는 것을 방지
- 프로덕션 컨테이너에서는 실행과 관련된 파일만 있으면 충분함

## 3. 공통 특징

이 네 가지 파일들은 모두 **개발 및 빌드 과정에서만 필요한 메타데이터 파일**들로, 실제 애플리케이션 실행에는 불필요하며 이미지 크기 최적화와 보안 강화를 위해 제외하는 것이 권장됩니다.